// Code generated by MockGen. DO NOT EDIT.
// Source: repository.go
//
// Generated by this command:
//
//	mockgen -source=repository.go -destination=../mock/bigmapdiff/mock.go -package=bigmapdiff -typed
//
// Package bigmapdiff is a generated GoMock package.
package bigmapdiff

import (
	reflect "reflect"

	bigmapdiff "github.com/baking-bad/bcdhub/internal/models/bigmapdiff"
	gomock "go.uber.org/mock/gomock"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
	ctrl     *gomock.Controller
	recorder *MockRepositoryMockRecorder
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
	mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository {
	mock := &MockRepository{ctrl: ctrl}
	mock.recorder = &MockRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder {
	return m.recorder
}

// Count mocks base method.
func (m *MockRepository) Count(ptr int64) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Count", ptr)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Count indicates an expected call of Count.
func (mr *MockRepositoryMockRecorder) Count(ptr any) *RepositoryCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockRepository)(nil).Count), ptr)
	return &RepositoryCountCall{Call: call}
}

// RepositoryCountCall wrap *gomock.Call
type RepositoryCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryCountCall) Return(arg0 int64, arg1 error) *RepositoryCountCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryCountCall) Do(f func(int64) (int64, error)) *RepositoryCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryCountCall) DoAndReturn(f func(int64) (int64, error)) *RepositoryCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Current mocks base method.
func (m *MockRepository) Current(keyHash string, ptr int64) (bigmapdiff.BigMapState, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Current", keyHash, ptr)
	ret0, _ := ret[0].(bigmapdiff.BigMapState)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Current indicates an expected call of Current.
func (mr *MockRepositoryMockRecorder) Current(keyHash, ptr any) *RepositoryCurrentCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Current", reflect.TypeOf((*MockRepository)(nil).Current), keyHash, ptr)
	return &RepositoryCurrentCall{Call: call}
}

// RepositoryCurrentCall wrap *gomock.Call
type RepositoryCurrentCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryCurrentCall) Return(arg0 bigmapdiff.BigMapState, arg1 error) *RepositoryCurrentCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryCurrentCall) Do(f func(string, int64) (bigmapdiff.BigMapState, error)) *RepositoryCurrentCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryCurrentCall) DoAndReturn(f func(string, int64) (bigmapdiff.BigMapState, error)) *RepositoryCurrentCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CurrentByContract mocks base method.
func (m *MockRepository) CurrentByContract(contract string) ([]bigmapdiff.BigMapState, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CurrentByContract", contract)
	ret0, _ := ret[0].([]bigmapdiff.BigMapState)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CurrentByContract indicates an expected call of CurrentByContract.
func (mr *MockRepositoryMockRecorder) CurrentByContract(contract any) *RepositoryCurrentByContractCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CurrentByContract", reflect.TypeOf((*MockRepository)(nil).CurrentByContract), contract)
	return &RepositoryCurrentByContractCall{Call: call}
}

// RepositoryCurrentByContractCall wrap *gomock.Call
type RepositoryCurrentByContractCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryCurrentByContractCall) Return(arg0 []bigmapdiff.BigMapState, arg1 error) *RepositoryCurrentByContractCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryCurrentByContractCall) Do(f func(string) ([]bigmapdiff.BigMapState, error)) *RepositoryCurrentByContractCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryCurrentByContractCall) DoAndReturn(f func(string) ([]bigmapdiff.BigMapState, error)) *RepositoryCurrentByContractCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Get mocks base method.
func (m *MockRepository) Get(ctx bigmapdiff.GetContext) ([]bigmapdiff.Bucket, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx)
	ret0, _ := ret[0].([]bigmapdiff.Bucket)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockRepositoryMockRecorder) Get(ctx any) *RepositoryGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockRepository)(nil).Get), ctx)
	return &RepositoryGetCall{Call: call}
}

// RepositoryGetCall wrap *gomock.Call
type RepositoryGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryGetCall) Return(arg0 []bigmapdiff.Bucket, arg1 error) *RepositoryGetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryGetCall) Do(f func(bigmapdiff.GetContext) ([]bigmapdiff.Bucket, error)) *RepositoryGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryGetCall) DoAndReturn(f func(bigmapdiff.GetContext) ([]bigmapdiff.Bucket, error)) *RepositoryGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetByAddress mocks base method.
func (m *MockRepository) GetByAddress(address string) ([]bigmapdiff.BigMapDiff, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByAddress", address)
	ret0, _ := ret[0].([]bigmapdiff.BigMapDiff)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByAddress indicates an expected call of GetByAddress.
func (mr *MockRepositoryMockRecorder) GetByAddress(address any) *RepositoryGetByAddressCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByAddress", reflect.TypeOf((*MockRepository)(nil).GetByAddress), address)
	return &RepositoryGetByAddressCall{Call: call}
}

// RepositoryGetByAddressCall wrap *gomock.Call
type RepositoryGetByAddressCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryGetByAddressCall) Return(arg0 []bigmapdiff.BigMapDiff, arg1 error) *RepositoryGetByAddressCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryGetByAddressCall) Do(f func(string) ([]bigmapdiff.BigMapDiff, error)) *RepositoryGetByAddressCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryGetByAddressCall) DoAndReturn(f func(string) ([]bigmapdiff.BigMapDiff, error)) *RepositoryGetByAddressCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetByPtr mocks base method.
func (m *MockRepository) GetByPtr(contract string, ptr int64) ([]bigmapdiff.BigMapState, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByPtr", contract, ptr)
	ret0, _ := ret[0].([]bigmapdiff.BigMapState)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByPtr indicates an expected call of GetByPtr.
func (mr *MockRepositoryMockRecorder) GetByPtr(contract, ptr any) *RepositoryGetByPtrCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByPtr", reflect.TypeOf((*MockRepository)(nil).GetByPtr), contract, ptr)
	return &RepositoryGetByPtrCall{Call: call}
}

// RepositoryGetByPtrCall wrap *gomock.Call
type RepositoryGetByPtrCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryGetByPtrCall) Return(arg0 []bigmapdiff.BigMapState, arg1 error) *RepositoryGetByPtrCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryGetByPtrCall) Do(f func(string, int64) ([]bigmapdiff.BigMapState, error)) *RepositoryGetByPtrCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryGetByPtrCall) DoAndReturn(f func(string, int64) ([]bigmapdiff.BigMapState, error)) *RepositoryGetByPtrCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetByPtrAndKeyHash mocks base method.
func (m *MockRepository) GetByPtrAndKeyHash(ptr int64, keyHash string, size, offset int64) ([]bigmapdiff.BigMapDiff, int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByPtrAndKeyHash", ptr, keyHash, size, offset)
	ret0, _ := ret[0].([]bigmapdiff.BigMapDiff)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetByPtrAndKeyHash indicates an expected call of GetByPtrAndKeyHash.
func (mr *MockRepositoryMockRecorder) GetByPtrAndKeyHash(ptr, keyHash, size, offset any) *RepositoryGetByPtrAndKeyHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByPtrAndKeyHash", reflect.TypeOf((*MockRepository)(nil).GetByPtrAndKeyHash), ptr, keyHash, size, offset)
	return &RepositoryGetByPtrAndKeyHashCall{Call: call}
}

// RepositoryGetByPtrAndKeyHashCall wrap *gomock.Call
type RepositoryGetByPtrAndKeyHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryGetByPtrAndKeyHashCall) Return(arg0 []bigmapdiff.BigMapDiff, arg1 int64, arg2 error) *RepositoryGetByPtrAndKeyHashCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryGetByPtrAndKeyHashCall) Do(f func(int64, string, int64, int64) ([]bigmapdiff.BigMapDiff, int64, error)) *RepositoryGetByPtrAndKeyHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryGetByPtrAndKeyHashCall) DoAndReturn(f func(int64, string, int64, int64) ([]bigmapdiff.BigMapDiff, int64, error)) *RepositoryGetByPtrAndKeyHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetForAddress mocks base method.
func (m *MockRepository) GetForAddress(address string) ([]bigmapdiff.BigMapState, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetForAddress", address)
	ret0, _ := ret[0].([]bigmapdiff.BigMapState)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetForAddress indicates an expected call of GetForAddress.
func (mr *MockRepositoryMockRecorder) GetForAddress(address any) *RepositoryGetForAddressCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetForAddress", reflect.TypeOf((*MockRepository)(nil).GetForAddress), address)
	return &RepositoryGetForAddressCall{Call: call}
}

// RepositoryGetForAddressCall wrap *gomock.Call
type RepositoryGetForAddressCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryGetForAddressCall) Return(arg0 []bigmapdiff.BigMapState, arg1 error) *RepositoryGetForAddressCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryGetForAddressCall) Do(f func(string) ([]bigmapdiff.BigMapState, error)) *RepositoryGetForAddressCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryGetForAddressCall) DoAndReturn(f func(string) ([]bigmapdiff.BigMapState, error)) *RepositoryGetForAddressCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetForOperation mocks base method.
func (m *MockRepository) GetForOperation(id int64) ([]bigmapdiff.BigMapDiff, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetForOperation", id)
	ret0, _ := ret[0].([]bigmapdiff.BigMapDiff)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetForOperation indicates an expected call of GetForOperation.
func (mr *MockRepositoryMockRecorder) GetForOperation(id any) *RepositoryGetForOperationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetForOperation", reflect.TypeOf((*MockRepository)(nil).GetForOperation), id)
	return &RepositoryGetForOperationCall{Call: call}
}

// RepositoryGetForOperationCall wrap *gomock.Call
type RepositoryGetForOperationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryGetForOperationCall) Return(arg0 []bigmapdiff.BigMapDiff, arg1 error) *RepositoryGetForOperationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryGetForOperationCall) Do(f func(int64) ([]bigmapdiff.BigMapDiff, error)) *RepositoryGetForOperationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryGetForOperationCall) DoAndReturn(f func(int64) ([]bigmapdiff.BigMapDiff, error)) *RepositoryGetForOperationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetStats mocks base method.
func (m *MockRepository) GetStats(ptr int64) (bigmapdiff.Stats, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStats", ptr)
	ret0, _ := ret[0].(bigmapdiff.Stats)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetStats indicates an expected call of GetStats.
func (mr *MockRepositoryMockRecorder) GetStats(ptr any) *RepositoryGetStatsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStats", reflect.TypeOf((*MockRepository)(nil).GetStats), ptr)
	return &RepositoryGetStatsCall{Call: call}
}

// RepositoryGetStatsCall wrap *gomock.Call
type RepositoryGetStatsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryGetStatsCall) Return(arg0 bigmapdiff.Stats, arg1 error) *RepositoryGetStatsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryGetStatsCall) Do(f func(int64) (bigmapdiff.Stats, error)) *RepositoryGetStatsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryGetStatsCall) DoAndReturn(f func(int64) (bigmapdiff.Stats, error)) *RepositoryGetStatsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetValuesByKey mocks base method.
func (m *MockRepository) GetValuesByKey(keyHash string) ([]bigmapdiff.BigMapState, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetValuesByKey", keyHash)
	ret0, _ := ret[0].([]bigmapdiff.BigMapState)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetValuesByKey indicates an expected call of GetValuesByKey.
func (mr *MockRepositoryMockRecorder) GetValuesByKey(keyHash any) *RepositoryGetValuesByKeyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetValuesByKey", reflect.TypeOf((*MockRepository)(nil).GetValuesByKey), keyHash)
	return &RepositoryGetValuesByKeyCall{Call: call}
}

// RepositoryGetValuesByKeyCall wrap *gomock.Call
type RepositoryGetValuesByKeyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryGetValuesByKeyCall) Return(arg0 []bigmapdiff.BigMapState, arg1 error) *RepositoryGetValuesByKeyCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryGetValuesByKeyCall) Do(f func(string) ([]bigmapdiff.BigMapState, error)) *RepositoryGetValuesByKeyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryGetValuesByKeyCall) DoAndReturn(f func(string) ([]bigmapdiff.BigMapState, error)) *RepositoryGetValuesByKeyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Keys mocks base method.
func (m *MockRepository) Keys(ctx bigmapdiff.GetContext) ([]bigmapdiff.BigMapState, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Keys", ctx)
	ret0, _ := ret[0].([]bigmapdiff.BigMapState)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Keys indicates an expected call of Keys.
func (mr *MockRepositoryMockRecorder) Keys(ctx any) *RepositoryKeysCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Keys", reflect.TypeOf((*MockRepository)(nil).Keys), ctx)
	return &RepositoryKeysCall{Call: call}
}

// RepositoryKeysCall wrap *gomock.Call
type RepositoryKeysCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryKeysCall) Return(states []bigmapdiff.BigMapState, err error) *RepositoryKeysCall {
	c.Call = c.Call.Return(states, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryKeysCall) Do(f func(bigmapdiff.GetContext) ([]bigmapdiff.BigMapState, error)) *RepositoryKeysCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryKeysCall) DoAndReturn(f func(bigmapdiff.GetContext) ([]bigmapdiff.BigMapState, error)) *RepositoryKeysCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LastDiff mocks base method.
func (m *MockRepository) LastDiff(ptr int64, keyHash string, skipRemoved bool) (bigmapdiff.BigMapDiff, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LastDiff", ptr, keyHash, skipRemoved)
	ret0, _ := ret[0].(bigmapdiff.BigMapDiff)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LastDiff indicates an expected call of LastDiff.
func (mr *MockRepositoryMockRecorder) LastDiff(ptr, keyHash, skipRemoved any) *RepositoryLastDiffCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LastDiff", reflect.TypeOf((*MockRepository)(nil).LastDiff), ptr, keyHash, skipRemoved)
	return &RepositoryLastDiffCall{Call: call}
}

// RepositoryLastDiffCall wrap *gomock.Call
type RepositoryLastDiffCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryLastDiffCall) Return(arg0 bigmapdiff.BigMapDiff, arg1 error) *RepositoryLastDiffCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryLastDiffCall) Do(f func(int64, string, bool) (bigmapdiff.BigMapDiff, error)) *RepositoryLastDiffCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryLastDiffCall) DoAndReturn(f func(int64, string, bool) (bigmapdiff.BigMapDiff, error)) *RepositoryLastDiffCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Previous mocks base method.
func (m *MockRepository) Previous(arg0 []bigmapdiff.BigMapDiff) ([]bigmapdiff.BigMapDiff, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Previous", arg0)
	ret0, _ := ret[0].([]bigmapdiff.BigMapDiff)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Previous indicates an expected call of Previous.
func (mr *MockRepositoryMockRecorder) Previous(arg0 any) *RepositoryPreviousCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Previous", reflect.TypeOf((*MockRepository)(nil).Previous), arg0)
	return &RepositoryPreviousCall{Call: call}
}

// RepositoryPreviousCall wrap *gomock.Call
type RepositoryPreviousCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryPreviousCall) Return(arg0 []bigmapdiff.BigMapDiff, arg1 error) *RepositoryPreviousCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryPreviousCall) Do(f func([]bigmapdiff.BigMapDiff) ([]bigmapdiff.BigMapDiff, error)) *RepositoryPreviousCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryPreviousCall) DoAndReturn(f func([]bigmapdiff.BigMapDiff) ([]bigmapdiff.BigMapDiff, error)) *RepositoryPreviousCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StatesChangedAfter mocks base method.
func (m *MockRepository) StatesChangedAfter(level int64) ([]bigmapdiff.BigMapState, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StatesChangedAfter", level)
	ret0, _ := ret[0].([]bigmapdiff.BigMapState)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StatesChangedAfter indicates an expected call of StatesChangedAfter.
func (mr *MockRepositoryMockRecorder) StatesChangedAfter(level any) *RepositoryStatesChangedAfterCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StatesChangedAfter", reflect.TypeOf((*MockRepository)(nil).StatesChangedAfter), level)
	return &RepositoryStatesChangedAfterCall{Call: call}
}

// RepositoryStatesChangedAfterCall wrap *gomock.Call
type RepositoryStatesChangedAfterCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *RepositoryStatesChangedAfterCall) Return(arg0 []bigmapdiff.BigMapState, arg1 error) *RepositoryStatesChangedAfterCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *RepositoryStatesChangedAfterCall) Do(f func(int64) ([]bigmapdiff.BigMapState, error)) *RepositoryStatesChangedAfterCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *RepositoryStatesChangedAfterCall) DoAndReturn(f func(int64) ([]bigmapdiff.BigMapState, error)) *RepositoryStatesChangedAfterCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
